= Разработка элемента управления для Конструктора разметок

{dv} предлагает разработчикам возможность создавать собственные элементы управления и использовать их при проектировании разметки карточки в _Конструкторе разметок_.

// [WARNING]
// ====
// Для разработки элементов управления, совместимых с _Конструктором разметок_, требуется лицензия на компоненты (WinForms) DevExpress.
// ====

Элемент управления, совместимый с _Конструктором разметок_ -- это сборка, включающая в себя три обязательных компонента:

* Собственно элемент управления, который предоставляет графический интерфейс и необходимую бизнес-логику.
* Класс-контейнер, который обеспечивает совместимость с _Конструктором разметок_, предоставляет необходимые для _Конструктора разметок_ свойства, обеспечивает сохранение настроек элемента управления, а также передачу их значений в элемент управления.
* Контейнер расширения, содержащий информацию об элементах управления, реализованных в сборке (в одной сборке может быть определено несколько элементов управления).

В процессе загрузки разметки (в карточке, либо в _Конструкторе разметок_) механизмы _Конструктора разметок_ обращаются с зарегистрированными сборкам в поисках класса контейнера расширения. Если в сборке обнаружен класс данного типа -- вызывается его метод `GetControlExtensions`, который предоставляет данные о типах реализованных элементов управления. Каждая запись, возвращаемая методом `GetControlExtensions`, обязательно содержит тип класса-контейнера, а также может содержать типы вспомогательных сущностей, которые реализуют механизмы настройки элемента управления.

После создания компонента карточки инициализируются элементы управления с загрузкой в них данных и настроек.

Далее рассматривается создание элемента управления на примере разработки простого списка, в который должны быть загружены подразделения из Справочника сотрудников.

[NOTE]
====
Полный код проекта можно скачать по xref:ROOT:attachment$controlForStaff.zip[ссылке].
====

. Создать новый проект типа `Windows Forms Class Library`.
. В проект добавить элемент `XtraUserControl`, в котором будет реализован пользовательский интерфейс элемента управления.
+
[NOTE]
====
Вместо `XtraUserControl` можно использоваться стандартный `UserControl`.
====
+
. Реализовать обязательный интерфейс `xref:BackOffice-WinForms:Design/PropertyControls/IPropertyControl_IN.adoc[IPropertyControl]`, в котором определены ключевые функциональные возможности элемента управления: получение контекста объектов, установка и возвращение значения элемента управления, а также его базовые настройки, и др.
+
[source,csharp]
----
public partial class RealPropertyControl : XtraUserControl, IPropertyControl
{
 private IStaffService staffService; <.>

 public RealPropertyControl()
 {
  this.InitializeComponent();
 }

<.>

 public bool Hierarchy <.>
 {
  get;
  set;
 }

 public void LoadData() <.>
 {
  if (ObjectContext = null) return; <.>

  staffService = ObjectContext.GetService<IStaffService>();
  ComboBoxItemCollection coll = staffBox.Properties.Items;

  coll.BeginUpdate();
  foreach (var item in staffService.GetUnits(null, true, Hierarchy))
  {
   coll.Add(new StaffBoxItem(ObjectContext.GetObjectRef(item).Id, item.Name));
  }
  coll.EndUpdate();
 }

 private void staffBox_SelectedIndexChanged(object sender, EventArgs e) <.>
 {
  if (staffBox.SelectedIndex = -1) ControlValue = null;
   else ControlValue = (staffBox.SelectedItem as StaffBoxItem).Id;
  ControlValueChanged(this, e);
 }
}
----
<.> Сервис для работы со Справочником сотрудников.
<.> Реализация интерфейса `IPropertyControl`.
<.> Отображать в списке все подразделения или только подразделения верхнего уровня.
<.> Загрузка данных из Справочника сотрудников в элемент управления.
<.> Если контекст объектов не был передан, то загрузить данные не получится.
<.> Выбор значения в элементе управления.
+
Приведенный выше код представляет собой часть содержимого класса `RealPropertyControl`. Метод `LoadData`, загружающий данные из _Справочника сотрудников_, вызывается только после присвоения значения контексту объектов (свойство `ObjectContext`), таким образом можно быть уверенным, что при загрузке данных будет доступное соединение с сервером {dv}.
+
Загрузка данных может быть выполнена иным образом, к примеру при обращении пользователя или после изменения видимости элемента управления. Последний способ сработает, если элемент управления расположен на вкладке, не отображаемой при открытии карточки.
+
При загрузке данных учитывается значение свойства `Hierarchy`, которое может быть определено в настройках элемента управления в _Конструкторе разметок_. Данное свойство получает значение из класса-контейнера (будет реализован далее).
+
. Реализовать графический интерфейс пользователя для элемента управления.
// В данном примере элемент управления представляет собой простой (`DevExpress`) `ComboBoxEdit`, который может быть заменён почти без последствий на (`WinForms`) `ComboBox`.
. Создаем класс, реализующий контейнер для создаваемого элемента управления, который делает данный компонент доступным для _Конструктора разметок_.
+
[source,csharp]
----
public class RealLayoutItem : FixedLayoutControlItem<RealPropertyControl>
{
 private bool hierarchy;

 public override string ItemTypeName <.>
 {
  get
  {
   return "Собственный элемент управления";
  }
 }

 public override System.Drawing.Image CustomizationImage <.>
 {
  get
  {
   return SampleControl.Properties.Resources.ButtonIcon.ToBitmap();
  }
 }

 public override LayoutsPropertyType PropertyType <.>
 {
  get { return LayoutsPropertyType.DepartmentReference; } <.>
 }

 public override FieldType[] GetSupportedFieldTypes() <.>
 {
  return new FieldType[]
  {
   FieldType.RefId <.>
  };
 }

 public override Control Control <.>
 {
  get
  {
   return base.Control;
  } 
  set
  {
   base.Control = value;
   if (value != null)
   {
    this.PropertyControl.Hierarchy = hierarchy;
   }
  }
 }

 [XtraSerializableProperty] <.>
 public bool Hierarchy
 {
  get
  {
   if (base.PropertyControl != null)
    return base.PropertyControl.Hierarchy;
   return hierarchy;
  }
  set
  {
   if (this.PropertyControl != null)
    this.PropertyControl.Hierarchy = value;
   hierarchy = value;
  }
 }
}
----
<.> Возвращает название элемента управления, отображаемое в Конструкторе разметок.
<.> Возвращает иконку для элемента управления, отображаемую в Конструкторе разметок.
<.> Возвращает тип данные элемента управления, который используется при преобразовании для элемента управления его значения по умолчанию.
<.> В данном случае -- ссылка на подразделения.
<.> Возвращает список типов полей, с которыми работает элемент управления.
<.> В данном случае -- ссылочное поле.
<.> При установке элемента управления передаем настройки в него.
<.> Обеспечение передачи значения свойства в класс элемента управления.
+
Класс-контейнер наследуется от типа `FixedLayoutControlItem<T>`, где `T` -- тип контейнера элемента управления (был разработан ранее), и в самом простом случае должен содержать только переопределение свойства `PropertyType`. Свойство `PropertyType` должно возвращать тип данных элемента управления, что требуется для присвоения значения по умолчанию при создании новой карточки, в которой используется элемент управления.
+
Если элемент управления является настраиваемым, т.е. имеет дополнительные настройки в _Конструкторе разметок_, в приведенном классе должен быть реализован механизм передачи значений настроек в элемент управления, а также хранения присвоенных настройкам значений, через сериализации.
+
Для этого в класс добавляются свойства, аналогичные реализуемым настройкам с соответствующими типами. Свойства должны быть отмечены атрибутом `XtraSerializableProperty`. Для передачи значения настройки в элемент управления, переопределяется свойство `Control`, в котором присваивается значение свойству.
+
Помимо указанных функций, в класс-контейнере можно указать название элемента управления (иначе будет использовано название класса), отображаемое в _Конструкторе разметок_, а также его иконку. Помимо этого переопределить метод `GetSupportedFieldTypes`, который предоставляет список типов полей. С этими полями может работать элемент управления.
+
. Реализуем класс-обертку, предоставляющий _Конструктору разметок_ дополнительную информацию о дополнительных настройках элемента управления. В данном примере реализует единственное дополнительное свойство, определяющее логику загрузки подразделений из _Справочника сотрудников_. Класс должен наследовать от типа `SpecialPropertyWrapper<T>`.
+
.В параметре типа указывается класс-контейнер, реализованный ранее:
[source,csharp]
----
public class RealWrapper : SpecialPropertyWrapper<RealLayoutItem>
{
 [Category("Дополнительные настройки"), DisplayName("Все подразделения"), Description("Выводить все подразделения или только первый уровень")]
 [TypeConverter(typeof(BooleanTypeConverter))]
 public bool Hierarchy
 {
  get {
   return this.Item.Hierarchy;
  }
  set
  {
   this.Item.Hierarchy = value;
  }
 }
}
----
+
.Свойство помечается атрибутами, определяющим его название и категорию, в которой оно размещается:
* `Category` -- категория свойств, в которой размещается собственная настройка.
* `DisplayName` -- название свойства, отображаемое в Конструкторе разметок.
* `Description` -- дополнительное описание.
+
Также здесь установлен атрибут конвертера (`TypeConverter`), который формирует из значения свойства текстовое обозначение, отображаемое в _Конструкторе разметок_:
+
[source,csharp]
----
internal sealed class BooleanTypeConverter : BooleanConverter
{
 public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destType)
 {
  return (bool)value ? "Да" : "Нет";
 }

 public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
 {
  return string.Compare((string)value, "Да", StringComparison.OrdinalIgnoreCase) = 0;
 }
}
----
+
. Создать обязательный класс, унаследованный от `ControlExtensionInfoPackage`, который возвращает список всех элементов управления, реализованных в сборке:
+
--
[source,csharp]
----
public sealed class ExtensionPackage : ControlExtensionInfoPackage
{
 public override ControlExtensionInfo[] GetControlExtensions() <.>
 {
  return new ControlExtensionInfo[]
  {
   new ControlExtensionInfo(typeof(RealLayoutItem), typeof(RealWrapper))
  };
 }
}
----
<.> Переопределяем единственный метод, возвращающий список элементов управления.
+
Конструктор `ControlExtensionInfo` принимает тип контейнера элемента управления, а также может принимать, как в приведенном коде, тип обертки для свойств и тип формы, реализующей страницу настроек.
--
+
. После получения готовой сборки, её необходимо зарегистрировать на всех компьютерах в ветке реестра:
+
* `HKEY_CURRENT_USER\Software\DocsVision\BackOffice\Client\PropertyControls` -- для текущего пользователя.
* `{hklm}\Software\DocsVision\BackOffice\Client\PropertyControls` -- для всех пользователей.
+
В ветку требуется добавить строковый параметр, значение которого должно содержать полный путь к сборке, либо полное название класса, если сборка зарегистрирована в GAC.
+
[WARNING]
====
Ветка реестра может отличаться от приведенной при отличной разрядности операционной системы.
====

В случае успешной реализации и регистрации элемента управления в список элементов управления _Конструктора разметок_ будет добавлен реализованный компонент. Чтобы компонент отобразился в конструкторе разметок, необходимо перезапустить {wincl}.

Созданный компонент можно использовать для создания интерфейса карточки:

.Собственный элемент управления в общем списке
image::ROOT:custom-control-listed.png[Собственный элемент управления в общем списке]

Указанный элемент управления имеет дополнительную настройку, определяющую вариант загрузки списка подразделений из _Справочника сотрудников_.

Настройка доступна из свойства элемента управления:

.Свойства элемента управления
image::ROOT:control-properties.png[Свойства элемента управления]
