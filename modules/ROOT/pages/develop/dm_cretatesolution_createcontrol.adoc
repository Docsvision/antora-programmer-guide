= Разработка элемента управления для Конструктора разметок

Docsvision предлагает разработчикам возможность создавать собственные элементы управления и использовать их при проектировании разметки карточки в _Конструкторе разметок_.

[IMPORTANT]
====
Для разработки элементов управления, совместимых с _Конструктором разметок_, требуется лицензия на компоненты (WinForms) DevExpress.
====

Элемент управления, совместимый _Конструктором разметок_ -- это сборка, включающая в себя три обязательных компонента:

* Собственно элемент управления, который предоставляет графический интерфейс и необходимую бизнес-логику.
* Класс-контейнер, который обеспечивает совместимость к _Конструктором разметок_: предоставляет необходимые для _Конструктора разметок_ свойства, обеспечивает сохранение настроек элемента управления, а также передачу их значений в элемент управления.
* Контейнер расширения, содержащий информацию об элементах управления, реализованных в сборке (в одной сборке может быть определено несколько элементов управления).

В процессе загрузки разметки (в карточке, либо в _Конструкторе разметок_) механизмы _Конструктора разметок_ обращаются с зарегистрированным сборкам в поисках класса контейнера расширения. Если в сборке обнаружен класс данного типа -- вызывается его метод GetControlExtensions, который предоставляет данные о типах реализованных элементов управления. Каждая запись, возвращаемая методов GetControlExtensions, обязательно содержит тип класса-контейнера, а также может содержать типы вспомогательных сущностей, которые реализуют механизмы настройки элемента управления.

После создания компонента карточки инициализируются элементы управления с загрузкой в них данных и настроек.

Рассмотрим создание элемента управления на примере разработки простого списка, в который должны быть загружены подразделения из Справочника сотрудников#.

[NOTE]
====
Полный код проекта доступен по xref:attachment$controlForStaff.zip[ссылке].
====

. Создаем новый проект типа *Windows Forms Class Library*.
. В проект добавляем элемент *XtraUserControl*, в котором будет реализован пользовательский интерфейс элемента управления.
+
[NOTE]
====
Вместо XtraUserControl можно использоваться стандартный UserControl.
====
. Реализуем обязательный интерфейс xref:api/DocsVision/BackOffice/WinForms/Design/PropertyControls/IPropertyControl_IN.adoc[IPropertyControl], в котором определены ключевые функциональные возможности элемента управления: получение контекста объектов, установка и возвращение значения элемента управления, а также его базовые настройки, и др.
+
[source,csharp]
----
public partial class RealPropertyControl : XtraUserControl, IPropertyControl
{
 // Сервис для работы со Справочником сотрудников
 private IStaffService staffService;

 public RealPropertyControl()
 {
  this.InitializeComponent();
 }

 // Реализация интерфейса IPropertyControl
 //...
 //

 // Отображать в списке все подразделения или только подразделения верхнего уровня
 public bool Hierarchy
 {
  get;
  set;
 }

 // Загрузка данных из Справочника сотрудников в элемент управления
 public void LoadData()
 {
  // Если контекст объектов не был передан, то загрузить данные не получится
  if (ObjectContext = null) return;

  staffService = ObjectContext.GetService<IStaffService>();
  ComboBoxItemCollection coll = staffBox.Properties.Items;

  coll.BeginUpdate();
  foreach (var item in staffService.GetUnits(null, true, Hierarchy))
  {
   coll.Add(new StaffBoxItem(ObjectContext.GetObjectRef(item).Id, item.Name));
  }
  coll.EndUpdate();
 }

 // Выбор значения в элементе управления
 private void staffBox_SelectedIndexChanged(object sender, EventArgs e)
 {
  if (staffBox.SelectedIndex = -1) ControlValue = null;
   else ControlValue = (staffBox.SelectedItem as StaffBoxItem).Id;
  ControlValueChanged(this, e);
 }
}
----
+
Приведенный выше код представляет собой часть содержимого класса RealPropertyControl. Метод LoadData, загружающий данные из _Справочника сотрудников_, вызывается только после присвоения значения контексту объектов (свойство `ObjectContext`), т.о. можно быть уверенным, что при загрузке данных будет доступное соединение с сервером {dv}. Загрузка данных может быть выполнена иным образом, к примеру после изменения видимости элемента управления (сработает, если элемент управления расположен на вкладке, не отображаемой при открытии карточки) или при обращении пользователя.
+
При загрузке данных учитывается значение свойства `Hierarchy`, которое может быть определено в настройках элемента управления в _Конструкторе разметок_. Данное свойство получает значение из класса-контейнера (будет реализован далее).
. Реализуем графический интерфейс пользователя для элемента управления. В данном примере элемент управления представляет собой простой (DevExpress) ComboBoxEdit, который практически безболезненно может быть заменен на (WinForms) ComboBox.
. Создаем класс, реализующий контейнер для создаваемого элемента управления, который делает данный компонент доступным для _Конструктора разметок_.
+
[source,csharp]
----
public class RealLayoutItem : FixedLayoutControlItem<RealPropertyControl>
{
 private bool hierarchy;

 // Возвращает название элемента управления, отображаемое в Конструкторе разметок
 public override string ItemTypeName
 {
  get
  {
   return "Собственный элемент управления";
  }
 }

 // Возвращает иконку для элемента управления, отображаемую в Конструкторе разметок 
 public override System.Drawing.Image CustomizationImage
 {
  get
  {
   return SampleControl.Properties.Resources.ButtonIcon.ToBitmap();
  }
 }

 // Возвращает тип данные элемента управления, который используется при преобразовании для элемента управления его значения по умолчанию 
 public override LayoutsPropertyType PropertyType
 {
  // В данном случае -- ссылка на подразделения
  get { return LayoutsPropertyType.DepartmentReference; }
 }

 // Возвращает список типов полей, с которыми работает элемент управления
 public override FieldType[] GetSupportedFieldTypes()
 {
  return new FieldType[]
  {
   // В данном случае -- ссылочное поле
   FieldType.RefId
  };
 }

 // При установке элемента управления передаем настройки в него
 public override Control Control
 {
  get
  {
   return base.Control;
  } 
  set
  {
   base.Control = value;
   if (value != null)
   {
    this.PropertyControl.Hierarchy = hierarchy;
   }
  }
 }

 // Обеспечение передачи значения свойства в класс элемента управления
 [XtraSerializableProperty]
 public bool Hierarchy
 {
  get
  {
   if (base.PropertyControl != null)
    return base.PropertyControl.Hierarchy;
   return hierarchy;
  }
  set
  {
   if (this.PropertyControl != null)
    this.PropertyControl.Hierarchy = value;
   hierarchy = value;
  }
 }
}
----
+
Класс-контейнер наследуется от типа FixedLayoutControlItem<T>#, где T -- тип контейнера элемента управления (был разработан ранее), и в самом простом случае должен содержать только переопределение свойства `PropertyType`, которое должно возвращать тип данных элемента управления, что требуется для присвоения значения по умолчанию при создании новой карточки, в которой используется элемент управления.
+
Если элемент управления является настраиваемым (т.е. имеет дополнительные настройки в _Конструкторе разметок_) в приведенном классе должен быть реализован механизм передачи значений настроек в элемент управления, а также хранения присвоенных настройкам значений, через сериализации. Для этого в класс добавляются свойства, аналогичные реализуемым настройкам с соответствующими типами. Свойства должны быть отмечены атрибутом XtraSerializableProperty. Для передачи значения настройки в элемент управления, переопределяется свойство `Control`, в котором присваивается значение свойству.
+
Помимо указанных функций, в класс-контейнере можно указать название элемента управления (иначе будет использовано название класса), отображаемое в _Конструкторе разметок_, а также его иконку. Помимо этого переопределяем метод GetSupportedFieldTypes, который предоставляет список типов полей, с которыми может работать элемент управления.
. Реализуем класс-обертку, предоставляющий _Конструктору розеток_ дополнительную информацию о дополнительных настройках элемента управления. В данном примере реализует единственное дополнительное свойство, определяющее логику загрузки подразделений из _Справочника сотрудников_. Класс должен наследовать от типа SpecialPropertyWrapper<T>#. В параметре типа указывается класс-контейнер, реализованный ранее:
+
[source,csharp]
----
public class RealWrapper : SpecialPropertyWrapper<RealLayoutItem>
{
 [Category("Дополнительные настройки"), DisplayName("Все подразделения"), Description("Выводить все подразделения или только первый уровень")]
 [TypeConverter(typeof(BooleanTypeConverter))]
 public bool Hierarchy
 {
  get {
   return this.Item.Hierarchy;
  }
  set
  {
   this.Item.Hierarchy = value;
  }
 }
}
----
+
Свойство помечается атрибутами, определяющим его название и категорию, в которой оно размещается:
* Category -- категория свойств, в которой размещается собственная настройка;
* DisplayName -- название свойства, отображаемое в Конструкторе разметок;
* Description -- дополнительное описание.
+
Также здесь установлен атрибут конвертера (TypeConverter), который формирует из значения свойства текстовое обозначение, отображаемое в _Конструкторе разметок_:
+
[source,csharp]
----
internal sealed class BooleanTypeConverter : BooleanConverter
{
 public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destType)
 {
  return (bool)value ? "Да" : "Нет";
 }

 public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
 {
  return string.Compare((string)value, "Да", StringComparison.OrdinalIgnoreCase) = 0;
 }
}
----
. Создаем обязательны класс, унаследованный от ControlExtensionInfoPackage, который возвращает список всех элементов управления, реализованных в сборке:
+
[source,csharp]
----
public sealed class ExtensionPackage : ControlExtensionInfoPackage
{
 // Переопределяем единственный метод, возвращающий список элементов управления
 public override ControlExtensionInfo[] GetControlExtensions()
 {
  return new ControlExtensionInfo[]
  {
   new ControlExtensionInfo(typeof(RealLayoutItem), typeof(RealWrapper))
  };
 }
}
----
+
Конструктор ControlExtensionInfo принимает тип контейнера элемента управления, а также может принимать, как в приведенном коде, тип обертки для свойств и тип формы, реализующей страницу настроек.
. После получения готовой сборки, её необходимо зарегистрировать на всех компьютерах в ветке реестра:
* HKEY_CURRENT_USER\Software\DocsVision\BackOffice\5.5\Client\PropertyControls -- для текущего пользователя;
* HKEY_LOCAL_MACHINE\Software\DocsVision\BackOffice\5.5\Client\PropertyControls -- для всех пользователей.
+
В ветку требуется добавить строковый параметр, значение которого должно содержать полный путь к сборке, либо полное название класса, если сборка зарегистрирована в GAC.
+
[IMPORTANT]
====
Ветка реестра может отличаться от приведенной при отличной разрядности операционной системы.
====

В случае успешной реализации и регистрации элемента управления в список элементов управления _Конструктора разметок_ будет добавлен (потребуется перезапуск {dv} {wincl}) реализованный компонент, который возможно использовать для создания интерфейса карточки:

image::dm_cretatesolution_createcontrol.png[image]

Указанный элемент управления имеет дополнительную настройку, определяющую вариант загрузки списка подразделений из _Справочника сотрудников_, и доступную из свойства элемента управления:

image::dm_cretatesolution_createcontrol_conf.png[image]
